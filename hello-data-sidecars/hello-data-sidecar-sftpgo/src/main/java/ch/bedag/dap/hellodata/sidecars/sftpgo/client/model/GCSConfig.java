/*
 * SFTPGo
 * SFTPGo allows you to securely share your files over SFTP and optionally over HTTP/S, FTP/S and WebDAV as well. Several storage backends are supported and they are configurable per-user, so you can serve a local directory for a user and an S3 bucket (or part of it) for another one. SFTPGo also supports virtual folders, a virtual folder can use any of the supported storage backends. So you can have, for example, a user with the S3 backend mapping a Google Cloud Storage bucket (or part of it) on a specified path and an encrypted local filesystem on another one. Virtual folders can be private or shared among multiple users, for shared virtual folders you can define different quota limits for each user. SFTPGo supports groups to simplify the administration of multiple accounts by letting you assign settings once to a group, instead of multiple times to each individual user. The SFTPGo WebClient allows end users to change their credentials, browse and manage their files in the browser and setup two-factor authentication which works with Authy, Google Authenticator and other compatible apps. From the WebClient each authorized user can also create HTTP/S links to externally share files and folders securely, by setting limits to the number of downloads/uploads, protecting the share with a password, limiting access by source IP address, setting an automatic expiration date. 
 *
 * The version of the OpenAPI document: 2.6.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package ch.bedag.dap.hellodata.sidecars.sftpgo.client.model;

import java.util.Objects;
import java.util.Arrays;
import ch.bedag.dap.hellodata.sidecars.sftpgo.client.model.Secret;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;

/**
 * Google Cloud Storage configuration details. The \&quot;credentials\&quot; field must be populated only when adding/updating a user. It will be always omitted, since there are sensitive data, when you search/get users
 */
@JsonPropertyOrder({
  GCSConfig.JSON_PROPERTY_BUCKET,
  GCSConfig.JSON_PROPERTY_CREDENTIALS,
  GCSConfig.JSON_PROPERTY_AUTOMATIC_CREDENTIALS,
  GCSConfig.JSON_PROPERTY_STORAGE_CLASS,
  GCSConfig.JSON_PROPERTY_ACL,
  GCSConfig.JSON_PROPERTY_KEY_PREFIX,
  GCSConfig.JSON_PROPERTY_UPLOAD_PART_SIZE,
  GCSConfig.JSON_PROPERTY_UPLOAD_PART_MAX_TIME
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-12-10T09:15:17.190691+01:00[Europe/Warsaw]", comments = "Generator version: 7.9.0")
public class GCSConfig {
  public static final String JSON_PROPERTY_BUCKET = "bucket";
  private String bucket;

  public static final String JSON_PROPERTY_CREDENTIALS = "credentials";
  private Secret credentials;

  /**
   * Automatic credentials:   * &#x60;0&#x60; - disabled, explicit credentials, using a JSON credentials file, must be provided. This is the default value if the field is null   * &#x60;1&#x60; - enabled, we try to use the Application Default Credentials (ADC) strategy to find your application&#39;s credentials 
   */
  public enum AutomaticCredentialsEnum {
    NUMBER_0(0),
    
    NUMBER_1(1);

    private Integer value;

    AutomaticCredentialsEnum(Integer value) {
      this.value = value;
    }

    @JsonValue
    public Integer getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static AutomaticCredentialsEnum fromValue(Integer value) {
      for (AutomaticCredentialsEnum b : AutomaticCredentialsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_AUTOMATIC_CREDENTIALS = "automatic_credentials";
  private AutomaticCredentialsEnum automaticCredentials;

  public static final String JSON_PROPERTY_STORAGE_CLASS = "storage_class";
  private String storageClass;

  public static final String JSON_PROPERTY_ACL = "acl";
  private String acl;

  public static final String JSON_PROPERTY_KEY_PREFIX = "key_prefix";
  private String keyPrefix;

  public static final String JSON_PROPERTY_UPLOAD_PART_SIZE = "upload_part_size";
  private Integer uploadPartSize;

  public static final String JSON_PROPERTY_UPLOAD_PART_MAX_TIME = "upload_part_max_time";
  private Integer uploadPartMaxTime;

  public GCSConfig() {
  }

  public GCSConfig bucket(String bucket) {
    
    this.bucket = bucket;
    return this;
  }

  /**
   * Get bucket
   * @return bucket
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_BUCKET)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getBucket() {
    return bucket;
  }


  @JsonProperty(JSON_PROPERTY_BUCKET)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setBucket(String bucket) {
    this.bucket = bucket;
  }

  public GCSConfig credentials(Secret credentials) {
    
    this.credentials = credentials;
    return this;
  }

  /**
   * Get credentials
   * @return credentials
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_CREDENTIALS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Secret getCredentials() {
    return credentials;
  }


  @JsonProperty(JSON_PROPERTY_CREDENTIALS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCredentials(Secret credentials) {
    this.credentials = credentials;
  }

  public GCSConfig automaticCredentials(AutomaticCredentialsEnum automaticCredentials) {
    
    this.automaticCredentials = automaticCredentials;
    return this;
  }

  /**
   * Automatic credentials:   * &#x60;0&#x60; - disabled, explicit credentials, using a JSON credentials file, must be provided. This is the default value if the field is null   * &#x60;1&#x60; - enabled, we try to use the Application Default Credentials (ADC) strategy to find your application&#39;s credentials 
   * @return automaticCredentials
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_AUTOMATIC_CREDENTIALS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public AutomaticCredentialsEnum getAutomaticCredentials() {
    return automaticCredentials;
  }


  @JsonProperty(JSON_PROPERTY_AUTOMATIC_CREDENTIALS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAutomaticCredentials(AutomaticCredentialsEnum automaticCredentials) {
    this.automaticCredentials = automaticCredentials;
  }

  public GCSConfig storageClass(String storageClass) {
    
    this.storageClass = storageClass;
    return this;
  }

  /**
   * Get storageClass
   * @return storageClass
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_STORAGE_CLASS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getStorageClass() {
    return storageClass;
  }


  @JsonProperty(JSON_PROPERTY_STORAGE_CLASS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStorageClass(String storageClass) {
    this.storageClass = storageClass;
  }

  public GCSConfig acl(String acl) {
    
    this.acl = acl;
    return this;
  }

  /**
   * The ACL to apply to uploaded objects. Leave empty to use the default ACL. For more information and available ACLs, refer to the JSON API here: https://cloud.google.com/storage/docs/access-control/lists#predefined-acl
   * @return acl
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ACL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getAcl() {
    return acl;
  }


  @JsonProperty(JSON_PROPERTY_ACL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAcl(String acl) {
    this.acl = acl;
  }

  public GCSConfig keyPrefix(String keyPrefix) {
    
    this.keyPrefix = keyPrefix;
    return this;
  }

  /**
   * key_prefix is similar to a chroot directory for a local filesystem. If specified the user will only see contents that starts with this prefix and so you can restrict access to a specific virtual folder. The prefix, if not empty, must not start with \&quot;/\&quot; and must end with \&quot;/\&quot;. If empty the whole bucket contents will be available
   * @return keyPrefix
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_KEY_PREFIX)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getKeyPrefix() {
    return keyPrefix;
  }


  @JsonProperty(JSON_PROPERTY_KEY_PREFIX)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setKeyPrefix(String keyPrefix) {
    this.keyPrefix = keyPrefix;
  }

  public GCSConfig uploadPartSize(Integer uploadPartSize) {
    
    this.uploadPartSize = uploadPartSize;
    return this;
  }

  /**
   * The buffer size (in MB) to use for multipart uploads. The default value is 16MB. 0 means use the default
   * @return uploadPartSize
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_UPLOAD_PART_SIZE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getUploadPartSize() {
    return uploadPartSize;
  }


  @JsonProperty(JSON_PROPERTY_UPLOAD_PART_SIZE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setUploadPartSize(Integer uploadPartSize) {
    this.uploadPartSize = uploadPartSize;
  }

  public GCSConfig uploadPartMaxTime(Integer uploadPartMaxTime) {
    
    this.uploadPartMaxTime = uploadPartMaxTime;
    return this;
  }

  /**
   * The maximum time allowed, in seconds, to upload a single chunk. The default value is 32. 0 means use the default
   * @return uploadPartMaxTime
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_UPLOAD_PART_MAX_TIME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getUploadPartMaxTime() {
    return uploadPartMaxTime;
  }


  @JsonProperty(JSON_PROPERTY_UPLOAD_PART_MAX_TIME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setUploadPartMaxTime(Integer uploadPartMaxTime) {
    this.uploadPartMaxTime = uploadPartMaxTime;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GCSConfig gcSConfig = (GCSConfig) o;
    return Objects.equals(this.bucket, gcSConfig.bucket) &&
        Objects.equals(this.credentials, gcSConfig.credentials) &&
        Objects.equals(this.automaticCredentials, gcSConfig.automaticCredentials) &&
        Objects.equals(this.storageClass, gcSConfig.storageClass) &&
        Objects.equals(this.acl, gcSConfig.acl) &&
        Objects.equals(this.keyPrefix, gcSConfig.keyPrefix) &&
        Objects.equals(this.uploadPartSize, gcSConfig.uploadPartSize) &&
        Objects.equals(this.uploadPartMaxTime, gcSConfig.uploadPartMaxTime);
  }

  @Override
  public int hashCode() {
    return Objects.hash(bucket, credentials, automaticCredentials, storageClass, acl, keyPrefix, uploadPartSize, uploadPartMaxTime);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GCSConfig {\n");
    sb.append("    bucket: ").append(toIndentedString(bucket)).append("\n");
    sb.append("    credentials: ").append(toIndentedString(credentials)).append("\n");
    sb.append("    automaticCredentials: ").append(toIndentedString(automaticCredentials)).append("\n");
    sb.append("    storageClass: ").append(toIndentedString(storageClass)).append("\n");
    sb.append("    acl: ").append(toIndentedString(acl)).append("\n");
    sb.append("    keyPrefix: ").append(toIndentedString(keyPrefix)).append("\n");
    sb.append("    uploadPartSize: ").append(toIndentedString(uploadPartSize)).append("\n");
    sb.append("    uploadPartMaxTime: ").append(toIndentedString(uploadPartMaxTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

