/*
 * SFTPGo
 * SFTPGo allows you to securely share your files over SFTP and optionally over HTTP/S, FTP/S and WebDAV as well. Several storage backends are supported and they are configurable per-user, so you can serve a local directory for a user and an S3 bucket (or part of it) for another one. SFTPGo also supports virtual folders, a virtual folder can use any of the supported storage backends. So you can have, for example, a user with the S3 backend mapping a Google Cloud Storage bucket (or part of it) on a specified path and an encrypted local filesystem on another one. Virtual folders can be private or shared among multiple users, for shared virtual folders you can define different quota limits for each user. SFTPGo supports groups to simplify the administration of multiple accounts by letting you assign settings once to a group, instead of multiple times to each individual user. The SFTPGo WebClient allows end users to change their credentials, browse and manage their files in the browser and setup two-factor authentication which works with Authy, Google Authenticator and other compatible apps. From the WebClient each authorized user can also create HTTP/S links to externally share files and folders securely, by setting limits to the number of downloads/uploads, protecting the share with a password, limiting access by source IP address, setting an automatic expiration date. 
 *
 * The version of the OpenAPI document: 2.6.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package ch.bedag.dap.hellodata.sidecars.sftpgo.client.model;

import java.util.Objects;
import java.util.Arrays;
import ch.bedag.dap.hellodata.sidecars.sftpgo.client.model.Secret;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;

/**
 * S3 Compatible Object Storage configuration details
 */
@JsonPropertyOrder({
  S3Config.JSON_PROPERTY_BUCKET,
  S3Config.JSON_PROPERTY_REGION,
  S3Config.JSON_PROPERTY_ACCESS_KEY,
  S3Config.JSON_PROPERTY_ACCESS_SECRET,
  S3Config.JSON_PROPERTY_ROLE_ARN,
  S3Config.JSON_PROPERTY_SESSION_TOKEN,
  S3Config.JSON_PROPERTY_ENDPOINT,
  S3Config.JSON_PROPERTY_STORAGE_CLASS,
  S3Config.JSON_PROPERTY_ACL,
  S3Config.JSON_PROPERTY_UPLOAD_PART_SIZE,
  S3Config.JSON_PROPERTY_UPLOAD_CONCURRENCY,
  S3Config.JSON_PROPERTY_UPLOAD_PART_MAX_TIME,
  S3Config.JSON_PROPERTY_DOWNLOAD_PART_SIZE,
  S3Config.JSON_PROPERTY_DOWNLOAD_CONCURRENCY,
  S3Config.JSON_PROPERTY_DOWNLOAD_PART_MAX_TIME,
  S3Config.JSON_PROPERTY_FORCE_PATH_STYLE,
  S3Config.JSON_PROPERTY_KEY_PREFIX
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-12-10T09:15:17.190691+01:00[Europe/Warsaw]", comments = "Generator version: 7.9.0")
public class S3Config {
  public static final String JSON_PROPERTY_BUCKET = "bucket";
  private String bucket;

  public static final String JSON_PROPERTY_REGION = "region";
  private String region;

  public static final String JSON_PROPERTY_ACCESS_KEY = "access_key";
  private String accessKey;

  public static final String JSON_PROPERTY_ACCESS_SECRET = "access_secret";
  private Secret accessSecret;

  public static final String JSON_PROPERTY_ROLE_ARN = "role_arn";
  private String roleArn;

  public static final String JSON_PROPERTY_SESSION_TOKEN = "session_token";
  private String sessionToken;

  public static final String JSON_PROPERTY_ENDPOINT = "endpoint";
  private String endpoint;

  public static final String JSON_PROPERTY_STORAGE_CLASS = "storage_class";
  private String storageClass;

  public static final String JSON_PROPERTY_ACL = "acl";
  private String acl;

  public static final String JSON_PROPERTY_UPLOAD_PART_SIZE = "upload_part_size";
  private Integer uploadPartSize;

  public static final String JSON_PROPERTY_UPLOAD_CONCURRENCY = "upload_concurrency";
  private Integer uploadConcurrency;

  public static final String JSON_PROPERTY_UPLOAD_PART_MAX_TIME = "upload_part_max_time";
  private Integer uploadPartMaxTime;

  public static final String JSON_PROPERTY_DOWNLOAD_PART_SIZE = "download_part_size";
  private Integer downloadPartSize;

  public static final String JSON_PROPERTY_DOWNLOAD_CONCURRENCY = "download_concurrency";
  private Integer downloadConcurrency;

  public static final String JSON_PROPERTY_DOWNLOAD_PART_MAX_TIME = "download_part_max_time";
  private Integer downloadPartMaxTime;

  public static final String JSON_PROPERTY_FORCE_PATH_STYLE = "force_path_style";
  private Boolean forcePathStyle;

  public static final String JSON_PROPERTY_KEY_PREFIX = "key_prefix";
  private String keyPrefix;

  public S3Config() {
  }

  public S3Config bucket(String bucket) {
    
    this.bucket = bucket;
    return this;
  }

  /**
   * Get bucket
   * @return bucket
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_BUCKET)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getBucket() {
    return bucket;
  }


  @JsonProperty(JSON_PROPERTY_BUCKET)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setBucket(String bucket) {
    this.bucket = bucket;
  }

  public S3Config region(String region) {
    
    this.region = region;
    return this;
  }

  /**
   * Get region
   * @return region
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_REGION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getRegion() {
    return region;
  }


  @JsonProperty(JSON_PROPERTY_REGION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRegion(String region) {
    this.region = region;
  }

  public S3Config accessKey(String accessKey) {
    
    this.accessKey = accessKey;
    return this;
  }

  /**
   * Get accessKey
   * @return accessKey
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ACCESS_KEY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getAccessKey() {
    return accessKey;
  }


  @JsonProperty(JSON_PROPERTY_ACCESS_KEY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAccessKey(String accessKey) {
    this.accessKey = accessKey;
  }

  public S3Config accessSecret(Secret accessSecret) {
    
    this.accessSecret = accessSecret;
    return this;
  }

  /**
   * Get accessSecret
   * @return accessSecret
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ACCESS_SECRET)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Secret getAccessSecret() {
    return accessSecret;
  }


  @JsonProperty(JSON_PROPERTY_ACCESS_SECRET)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAccessSecret(Secret accessSecret) {
    this.accessSecret = accessSecret;
  }

  public S3Config roleArn(String roleArn) {
    
    this.roleArn = roleArn;
    return this;
  }

  /**
   * Optional IAM Role ARN to assume
   * @return roleArn
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ROLE_ARN)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getRoleArn() {
    return roleArn;
  }


  @JsonProperty(JSON_PROPERTY_ROLE_ARN)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRoleArn(String roleArn) {
    this.roleArn = roleArn;
  }

  public S3Config sessionToken(String sessionToken) {
    
    this.sessionToken = sessionToken;
    return this;
  }

  /**
   * Optional Session token that is a part of temporary security credentials provisioned by AWS STS
   * @return sessionToken
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_SESSION_TOKEN)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getSessionToken() {
    return sessionToken;
  }


  @JsonProperty(JSON_PROPERTY_SESSION_TOKEN)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSessionToken(String sessionToken) {
    this.sessionToken = sessionToken;
  }

  public S3Config endpoint(String endpoint) {
    
    this.endpoint = endpoint;
    return this;
  }

  /**
   * optional endpoint
   * @return endpoint
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ENDPOINT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getEndpoint() {
    return endpoint;
  }


  @JsonProperty(JSON_PROPERTY_ENDPOINT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setEndpoint(String endpoint) {
    this.endpoint = endpoint;
  }

  public S3Config storageClass(String storageClass) {
    
    this.storageClass = storageClass;
    return this;
  }

  /**
   * Get storageClass
   * @return storageClass
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_STORAGE_CLASS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getStorageClass() {
    return storageClass;
  }


  @JsonProperty(JSON_PROPERTY_STORAGE_CLASS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStorageClass(String storageClass) {
    this.storageClass = storageClass;
  }

  public S3Config acl(String acl) {
    
    this.acl = acl;
    return this;
  }

  /**
   * The canned ACL to apply to uploaded objects. Leave empty to use the default ACL. For more information and available ACLs, see here: https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl
   * @return acl
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ACL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getAcl() {
    return acl;
  }


  @JsonProperty(JSON_PROPERTY_ACL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAcl(String acl) {
    this.acl = acl;
  }

  public S3Config uploadPartSize(Integer uploadPartSize) {
    
    this.uploadPartSize = uploadPartSize;
    return this;
  }

  /**
   * the buffer size (in MB) to use for multipart uploads. The minimum allowed part size is 5MB, and if this value is set to zero, the default value (5MB) for the AWS SDK will be used. The minimum allowed value is 5.
   * @return uploadPartSize
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_UPLOAD_PART_SIZE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getUploadPartSize() {
    return uploadPartSize;
  }


  @JsonProperty(JSON_PROPERTY_UPLOAD_PART_SIZE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setUploadPartSize(Integer uploadPartSize) {
    this.uploadPartSize = uploadPartSize;
  }

  public S3Config uploadConcurrency(Integer uploadConcurrency) {
    
    this.uploadConcurrency = uploadConcurrency;
    return this;
  }

  /**
   * the number of parts to upload in parallel. If this value is set to zero, the default value (5) will be used
   * @return uploadConcurrency
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_UPLOAD_CONCURRENCY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getUploadConcurrency() {
    return uploadConcurrency;
  }


  @JsonProperty(JSON_PROPERTY_UPLOAD_CONCURRENCY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setUploadConcurrency(Integer uploadConcurrency) {
    this.uploadConcurrency = uploadConcurrency;
  }

  public S3Config uploadPartMaxTime(Integer uploadPartMaxTime) {
    
    this.uploadPartMaxTime = uploadPartMaxTime;
    return this;
  }

  /**
   * the maximum time allowed, in seconds, to upload a single chunk (the chunk size is defined via \&quot;upload_part_size\&quot;). 0 means no timeout
   * @return uploadPartMaxTime
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_UPLOAD_PART_MAX_TIME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getUploadPartMaxTime() {
    return uploadPartMaxTime;
  }


  @JsonProperty(JSON_PROPERTY_UPLOAD_PART_MAX_TIME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setUploadPartMaxTime(Integer uploadPartMaxTime) {
    this.uploadPartMaxTime = uploadPartMaxTime;
  }

  public S3Config downloadPartSize(Integer downloadPartSize) {
    
    this.downloadPartSize = downloadPartSize;
    return this;
  }

  /**
   * the buffer size (in MB) to use for multipart downloads. The minimum allowed part size is 5MB, and if this value is set to zero, the default value (5MB) for the AWS SDK will be used. The minimum allowed value is 5. Ignored for partial downloads
   * @return downloadPartSize
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_DOWNLOAD_PART_SIZE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getDownloadPartSize() {
    return downloadPartSize;
  }


  @JsonProperty(JSON_PROPERTY_DOWNLOAD_PART_SIZE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDownloadPartSize(Integer downloadPartSize) {
    this.downloadPartSize = downloadPartSize;
  }

  public S3Config downloadConcurrency(Integer downloadConcurrency) {
    
    this.downloadConcurrency = downloadConcurrency;
    return this;
  }

  /**
   * the number of parts to download in parallel. If this value is set to zero, the default value (5) will be used. Ignored for partial downloads
   * @return downloadConcurrency
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_DOWNLOAD_CONCURRENCY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getDownloadConcurrency() {
    return downloadConcurrency;
  }


  @JsonProperty(JSON_PROPERTY_DOWNLOAD_CONCURRENCY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDownloadConcurrency(Integer downloadConcurrency) {
    this.downloadConcurrency = downloadConcurrency;
  }

  public S3Config downloadPartMaxTime(Integer downloadPartMaxTime) {
    
    this.downloadPartMaxTime = downloadPartMaxTime;
    return this;
  }

  /**
   * the maximum time allowed, in seconds, to download a single chunk (the chunk size is defined via \&quot;download_part_size\&quot;). 0 means no timeout. Ignored for partial downloads.
   * @return downloadPartMaxTime
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_DOWNLOAD_PART_MAX_TIME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getDownloadPartMaxTime() {
    return downloadPartMaxTime;
  }


  @JsonProperty(JSON_PROPERTY_DOWNLOAD_PART_MAX_TIME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDownloadPartMaxTime(Integer downloadPartMaxTime) {
    this.downloadPartMaxTime = downloadPartMaxTime;
  }

  public S3Config forcePathStyle(Boolean forcePathStyle) {
    
    this.forcePathStyle = forcePathStyle;
    return this;
  }

  /**
   * Set this to \&quot;true\&quot; to force the request to use path-style addressing, i.e., \&quot;http://s3.amazonaws.com/BUCKET/KEY\&quot;. By default, the S3 client will use virtual hosted bucket addressing when possible (\&quot;http://BUCKET.s3.amazonaws.com/KEY\&quot;)
   * @return forcePathStyle
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_FORCE_PATH_STYLE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getForcePathStyle() {
    return forcePathStyle;
  }


  @JsonProperty(JSON_PROPERTY_FORCE_PATH_STYLE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setForcePathStyle(Boolean forcePathStyle) {
    this.forcePathStyle = forcePathStyle;
  }

  public S3Config keyPrefix(String keyPrefix) {
    
    this.keyPrefix = keyPrefix;
    return this;
  }

  /**
   * key_prefix is similar to a chroot directory for a local filesystem. If specified the user will only see contents that starts with this prefix and so you can restrict access to a specific virtual folder. The prefix, if not empty, must not start with \&quot;/\&quot; and must end with \&quot;/\&quot;. If empty the whole bucket contents will be available
   * @return keyPrefix
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_KEY_PREFIX)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getKeyPrefix() {
    return keyPrefix;
  }


  @JsonProperty(JSON_PROPERTY_KEY_PREFIX)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setKeyPrefix(String keyPrefix) {
    this.keyPrefix = keyPrefix;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    S3Config s3Config = (S3Config) o;
    return Objects.equals(this.bucket, s3Config.bucket) &&
        Objects.equals(this.region, s3Config.region) &&
        Objects.equals(this.accessKey, s3Config.accessKey) &&
        Objects.equals(this.accessSecret, s3Config.accessSecret) &&
        Objects.equals(this.roleArn, s3Config.roleArn) &&
        Objects.equals(this.sessionToken, s3Config.sessionToken) &&
        Objects.equals(this.endpoint, s3Config.endpoint) &&
        Objects.equals(this.storageClass, s3Config.storageClass) &&
        Objects.equals(this.acl, s3Config.acl) &&
        Objects.equals(this.uploadPartSize, s3Config.uploadPartSize) &&
        Objects.equals(this.uploadConcurrency, s3Config.uploadConcurrency) &&
        Objects.equals(this.uploadPartMaxTime, s3Config.uploadPartMaxTime) &&
        Objects.equals(this.downloadPartSize, s3Config.downloadPartSize) &&
        Objects.equals(this.downloadConcurrency, s3Config.downloadConcurrency) &&
        Objects.equals(this.downloadPartMaxTime, s3Config.downloadPartMaxTime) &&
        Objects.equals(this.forcePathStyle, s3Config.forcePathStyle) &&
        Objects.equals(this.keyPrefix, s3Config.keyPrefix);
  }

  @Override
  public int hashCode() {
    return Objects.hash(bucket, region, accessKey, accessSecret, roleArn, sessionToken, endpoint, storageClass, acl, uploadPartSize, uploadConcurrency, uploadPartMaxTime, downloadPartSize, downloadConcurrency, downloadPartMaxTime, forcePathStyle, keyPrefix);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class S3Config {\n");
    sb.append("    bucket: ").append(toIndentedString(bucket)).append("\n");
    sb.append("    region: ").append(toIndentedString(region)).append("\n");
    sb.append("    accessKey: ").append(toIndentedString(accessKey)).append("\n");
    sb.append("    accessSecret: ").append(toIndentedString(accessSecret)).append("\n");
    sb.append("    roleArn: ").append(toIndentedString(roleArn)).append("\n");
    sb.append("    sessionToken: ").append(toIndentedString(sessionToken)).append("\n");
    sb.append("    endpoint: ").append(toIndentedString(endpoint)).append("\n");
    sb.append("    storageClass: ").append(toIndentedString(storageClass)).append("\n");
    sb.append("    acl: ").append(toIndentedString(acl)).append("\n");
    sb.append("    uploadPartSize: ").append(toIndentedString(uploadPartSize)).append("\n");
    sb.append("    uploadConcurrency: ").append(toIndentedString(uploadConcurrency)).append("\n");
    sb.append("    uploadPartMaxTime: ").append(toIndentedString(uploadPartMaxTime)).append("\n");
    sb.append("    downloadPartSize: ").append(toIndentedString(downloadPartSize)).append("\n");
    sb.append("    downloadConcurrency: ").append(toIndentedString(downloadConcurrency)).append("\n");
    sb.append("    downloadPartMaxTime: ").append(toIndentedString(downloadPartMaxTime)).append("\n");
    sb.append("    forcePathStyle: ").append(toIndentedString(forcePathStyle)).append("\n");
    sb.append("    keyPrefix: ").append(toIndentedString(keyPrefix)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

