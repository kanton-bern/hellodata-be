/*
 * SFTPGo
 * SFTPGo allows you to securely share your files over SFTP and optionally over HTTP/S, FTP/S and WebDAV as well. Several storage backends are supported and they are configurable per-user, so you can serve a local directory for a user and an S3 bucket (or part of it) for another one. SFTPGo also supports virtual folders, a virtual folder can use any of the supported storage backends. So you can have, for example, a user with the S3 backend mapping a Google Cloud Storage bucket (or part of it) on a specified path and an encrypted local filesystem on another one. Virtual folders can be private or shared among multiple users, for shared virtual folders you can define different quota limits for each user. SFTPGo supports groups to simplify the administration of multiple accounts by letting you assign settings once to a group, instead of multiple times to each individual user. The SFTPGo WebClient allows end users to change their credentials, browse and manage their files in the browser and setup two-factor authentication which works with Authy, Google Authenticator and other compatible apps. From the WebClient each authorized user can also create HTTP/S links to externally share files and folders securely, by setting limits to the number of downloads/uploads, protecting the share with a password, limiting access by source IP address, setting an automatic expiration date. 
 *
 * The version of the OpenAPI document: 2.6.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package ch.bedag.dap.hellodata.sidecars.sftpgo.client.model;

import java.util.Objects;
import java.util.Arrays;
import ch.bedag.dap.hellodata.sidecars.sftpgo.client.model.ShareScope;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;

/**
 * Share
 */
@JsonPropertyOrder({
  Share.JSON_PROPERTY_ID,
  Share.JSON_PROPERTY_NAME,
  Share.JSON_PROPERTY_DESCRIPTION,
  Share.JSON_PROPERTY_SCOPE,
  Share.JSON_PROPERTY_PATHS,
  Share.JSON_PROPERTY_USERNAME,
  Share.JSON_PROPERTY_CREATED_AT,
  Share.JSON_PROPERTY_UPDATED_AT,
  Share.JSON_PROPERTY_LAST_USE_AT,
  Share.JSON_PROPERTY_EXPIRES_AT,
  Share.JSON_PROPERTY_PASSWORD,
  Share.JSON_PROPERTY_MAX_TOKENS,
  Share.JSON_PROPERTY_USED_TOKENS,
  Share.JSON_PROPERTY_ALLOW_FROM
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-12-10T09:15:17.190691+01:00[Europe/Warsaw]", comments = "Generator version: 7.9.0")
public class Share {
  public static final String JSON_PROPERTY_ID = "id";
  private String id;

  public static final String JSON_PROPERTY_NAME = "name";
  private String name;

  public static final String JSON_PROPERTY_DESCRIPTION = "description";
  private String description;

  public static final String JSON_PROPERTY_SCOPE = "scope";
  private ShareScope scope;

  public static final String JSON_PROPERTY_PATHS = "paths";
  private List<String> paths = new ArrayList<>();

  public static final String JSON_PROPERTY_USERNAME = "username";
  private String username;

  public static final String JSON_PROPERTY_CREATED_AT = "created_at";
  private Long createdAt;

  public static final String JSON_PROPERTY_UPDATED_AT = "updated_at";
  private Long updatedAt;

  public static final String JSON_PROPERTY_LAST_USE_AT = "last_use_at";
  private Long lastUseAt;

  public static final String JSON_PROPERTY_EXPIRES_AT = "expires_at";
  private Long expiresAt;

  public static final String JSON_PROPERTY_PASSWORD = "password";
  private String password;

  public static final String JSON_PROPERTY_MAX_TOKENS = "max_tokens";
  private Integer maxTokens;

  public static final String JSON_PROPERTY_USED_TOKENS = "used_tokens";
  private Integer usedTokens;

  public static final String JSON_PROPERTY_ALLOW_FROM = "allow_from";
  private List<String> allowFrom = new ArrayList<>();

  public Share() {
  }

  public Share id(String id) {
    
    this.id = id;
    return this;
  }

  /**
   * auto-generated unique share identifier
   * @return id
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getId() {
    return id;
  }


  @JsonProperty(JSON_PROPERTY_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setId(String id) {
    this.id = id;
  }

  public Share name(String name) {
    
    this.name = name;
    return this;
  }

  /**
   * Get name
   * @return name
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getName() {
    return name;
  }


  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setName(String name) {
    this.name = name;
  }

  public Share description(String description) {
    
    this.description = description;
    return this;
  }

  /**
   * optional description
   * @return description
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_DESCRIPTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getDescription() {
    return description;
  }


  @JsonProperty(JSON_PROPERTY_DESCRIPTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDescription(String description) {
    this.description = description;
  }

  public Share scope(ShareScope scope) {
    
    this.scope = scope;
    return this;
  }

  /**
   * Get scope
   * @return scope
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_SCOPE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public ShareScope getScope() {
    return scope;
  }


  @JsonProperty(JSON_PROPERTY_SCOPE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setScope(ShareScope scope) {
    this.scope = scope;
  }

  public Share paths(List<String> paths) {
    
    this.paths = paths;
    return this;
  }

  public Share addPathsItem(String pathsItem) {
    if (this.paths == null) {
      this.paths = new ArrayList<>();
    }
    this.paths.add(pathsItem);
    return this;
  }

  /**
   * paths to files or directories, for share scope write this array must contain exactly one directory. Paths will not be validated on save so you can also create them after creating the share
   * @return paths
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_PATHS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<String> getPaths() {
    return paths;
  }


  @JsonProperty(JSON_PROPERTY_PATHS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setPaths(List<String> paths) {
    this.paths = paths;
  }

  public Share username(String username) {
    
    this.username = username;
    return this;
  }

  /**
   * Get username
   * @return username
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_USERNAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getUsername() {
    return username;
  }


  @JsonProperty(JSON_PROPERTY_USERNAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setUsername(String username) {
    this.username = username;
  }

  public Share createdAt(Long createdAt) {
    
    this.createdAt = createdAt;
    return this;
  }

  /**
   * creation time as unix timestamp in milliseconds
   * @return createdAt
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_CREATED_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Long getCreatedAt() {
    return createdAt;
  }


  @JsonProperty(JSON_PROPERTY_CREATED_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCreatedAt(Long createdAt) {
    this.createdAt = createdAt;
  }

  public Share updatedAt(Long updatedAt) {
    
    this.updatedAt = updatedAt;
    return this;
  }

  /**
   * last update time as unix timestamp in milliseconds
   * @return updatedAt
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_UPDATED_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Long getUpdatedAt() {
    return updatedAt;
  }


  @JsonProperty(JSON_PROPERTY_UPDATED_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setUpdatedAt(Long updatedAt) {
    this.updatedAt = updatedAt;
  }

  public Share lastUseAt(Long lastUseAt) {
    
    this.lastUseAt = lastUseAt;
    return this;
  }

  /**
   * last use time as unix timestamp in milliseconds
   * @return lastUseAt
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_LAST_USE_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Long getLastUseAt() {
    return lastUseAt;
  }


  @JsonProperty(JSON_PROPERTY_LAST_USE_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLastUseAt(Long lastUseAt) {
    this.lastUseAt = lastUseAt;
  }

  public Share expiresAt(Long expiresAt) {
    
    this.expiresAt = expiresAt;
    return this;
  }

  /**
   * optional share expiration, as unix timestamp in milliseconds. 0 means no expiration
   * @return expiresAt
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_EXPIRES_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Long getExpiresAt() {
    return expiresAt;
  }


  @JsonProperty(JSON_PROPERTY_EXPIRES_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setExpiresAt(Long expiresAt) {
    this.expiresAt = expiresAt;
  }

  public Share password(String password) {
    
    this.password = password;
    return this;
  }

  /**
   * optional password to protect the share. The special value \&quot;[**redacted**]\&quot; means that a password has been set, you can use this value if you want to preserve the current password when you update a share
   * @return password
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_PASSWORD)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getPassword() {
    return password;
  }


  @JsonProperty(JSON_PROPERTY_PASSWORD)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setPassword(String password) {
    this.password = password;
  }

  public Share maxTokens(Integer maxTokens) {
    
    this.maxTokens = maxTokens;
    return this;
  }

  /**
   * maximum allowed access tokens. 0 means no limit
   * @return maxTokens
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_MAX_TOKENS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getMaxTokens() {
    return maxTokens;
  }


  @JsonProperty(JSON_PROPERTY_MAX_TOKENS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setMaxTokens(Integer maxTokens) {
    this.maxTokens = maxTokens;
  }

  public Share usedTokens(Integer usedTokens) {
    
    this.usedTokens = usedTokens;
    return this;
  }

  /**
   * Get usedTokens
   * @return usedTokens
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_USED_TOKENS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getUsedTokens() {
    return usedTokens;
  }


  @JsonProperty(JSON_PROPERTY_USED_TOKENS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setUsedTokens(Integer usedTokens) {
    this.usedTokens = usedTokens;
  }

  public Share allowFrom(List<String> allowFrom) {
    
    this.allowFrom = allowFrom;
    return this;
  }

  public Share addAllowFromItem(String allowFromItem) {
    if (this.allowFrom == null) {
      this.allowFrom = new ArrayList<>();
    }
    this.allowFrom.add(allowFromItem);
    return this;
  }

  /**
   * Limit the share availability to these IP/Mask. IP/Mask must be in CIDR notation as defined in RFC 4632 and RFC 4291, for example \&quot;192.0.2.0/24\&quot; or \&quot;2001:db8::/32\&quot;. An empty list means no restrictions
   * @return allowFrom
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ALLOW_FROM)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<String> getAllowFrom() {
    return allowFrom;
  }


  @JsonProperty(JSON_PROPERTY_ALLOW_FROM)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAllowFrom(List<String> allowFrom) {
    this.allowFrom = allowFrom;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Share share = (Share) o;
    return Objects.equals(this.id, share.id) &&
        Objects.equals(this.name, share.name) &&
        Objects.equals(this.description, share.description) &&
        Objects.equals(this.scope, share.scope) &&
        Objects.equals(this.paths, share.paths) &&
        Objects.equals(this.username, share.username) &&
        Objects.equals(this.createdAt, share.createdAt) &&
        Objects.equals(this.updatedAt, share.updatedAt) &&
        Objects.equals(this.lastUseAt, share.lastUseAt) &&
        Objects.equals(this.expiresAt, share.expiresAt) &&
        Objects.equals(this.password, share.password) &&
        Objects.equals(this.maxTokens, share.maxTokens) &&
        Objects.equals(this.usedTokens, share.usedTokens) &&
        Objects.equals(this.allowFrom, share.allowFrom);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, name, description, scope, paths, username, createdAt, updatedAt, lastUseAt, expiresAt, password, maxTokens, usedTokens, allowFrom);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Share {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    scope: ").append(toIndentedString(scope)).append("\n");
    sb.append("    paths: ").append(toIndentedString(paths)).append("\n");
    sb.append("    username: ").append(toIndentedString(username)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    updatedAt: ").append(toIndentedString(updatedAt)).append("\n");
    sb.append("    lastUseAt: ").append(toIndentedString(lastUseAt)).append("\n");
    sb.append("    expiresAt: ").append(toIndentedString(expiresAt)).append("\n");
    sb.append("    password: ").append(toIndentedString(password)).append("\n");
    sb.append("    maxTokens: ").append(toIndentedString(maxTokens)).append("\n");
    sb.append("    usedTokens: ").append(toIndentedString(usedTokens)).append("\n");
    sb.append("    allowFrom: ").append(toIndentedString(allowFrom)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

