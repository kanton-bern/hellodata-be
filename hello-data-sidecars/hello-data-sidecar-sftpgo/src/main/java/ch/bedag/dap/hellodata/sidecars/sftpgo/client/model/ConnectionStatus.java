/*
 * SFTPGo
 * SFTPGo allows you to securely share your files over SFTP and optionally over HTTP/S, FTP/S and WebDAV as well. Several storage backends are supported and they are configurable per-user, so you can serve a local directory for a user and an S3 bucket (or part of it) for another one. SFTPGo also supports virtual folders, a virtual folder can use any of the supported storage backends. So you can have, for example, a user with the S3 backend mapping a Google Cloud Storage bucket (or part of it) on a specified path and an encrypted local filesystem on another one. Virtual folders can be private or shared among multiple users, for shared virtual folders you can define different quota limits for each user. SFTPGo supports groups to simplify the administration of multiple accounts by letting you assign settings once to a group, instead of multiple times to each individual user. The SFTPGo WebClient allows end users to change their credentials, browse and manage their files in the browser and setup two-factor authentication which works with Authy, Google Authenticator and other compatible apps. From the WebClient each authorized user can also create HTTP/S links to externally share files and folders securely, by setting limits to the number of downloads/uploads, protecting the share with a password, limiting access by source IP address, setting an automatic expiration date. 
 *
 * The version of the OpenAPI document: 2.6.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package ch.bedag.dap.hellodata.sidecars.sftpgo.client.model;

import java.util.Objects;
import java.util.Arrays;
import ch.bedag.dap.hellodata.sidecars.sftpgo.client.model.Transfer;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;

/**
 * ConnectionStatus
 */
@JsonPropertyOrder({
  ConnectionStatus.JSON_PROPERTY_USERNAME,
  ConnectionStatus.JSON_PROPERTY_CONNECTION_ID,
  ConnectionStatus.JSON_PROPERTY_CLIENT_VERSION,
  ConnectionStatus.JSON_PROPERTY_REMOTE_ADDRESS,
  ConnectionStatus.JSON_PROPERTY_CONNECTION_TIME,
  ConnectionStatus.JSON_PROPERTY_COMMAND,
  ConnectionStatus.JSON_PROPERTY_LAST_ACTIVITY,
  ConnectionStatus.JSON_PROPERTY_PROTOCOL,
  ConnectionStatus.JSON_PROPERTY_ACTIVE_TRANSFERS,
  ConnectionStatus.JSON_PROPERTY_NODE
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-12-10T09:15:17.190691+01:00[Europe/Warsaw]", comments = "Generator version: 7.9.0")
public class ConnectionStatus {
  public static final String JSON_PROPERTY_USERNAME = "username";
  private String username;

  public static final String JSON_PROPERTY_CONNECTION_ID = "connection_id";
  private String connectionId;

  public static final String JSON_PROPERTY_CLIENT_VERSION = "client_version";
  private String clientVersion;

  public static final String JSON_PROPERTY_REMOTE_ADDRESS = "remote_address";
  private String remoteAddress;

  public static final String JSON_PROPERTY_CONNECTION_TIME = "connection_time";
  private Long connectionTime;

  public static final String JSON_PROPERTY_COMMAND = "command";
  private String command;

  public static final String JSON_PROPERTY_LAST_ACTIVITY = "last_activity";
  private Long lastActivity;

  /**
   * Gets or Sets protocol
   */
  public enum ProtocolEnum {
    SFTP("SFTP"),
    
    SCP("SCP"),
    
    SSH("SSH"),
    
    FTP("FTP"),
    
    DAV("DAV");

    private String value;

    ProtocolEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static ProtocolEnum fromValue(String value) {
      for (ProtocolEnum b : ProtocolEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_PROTOCOL = "protocol";
  private ProtocolEnum protocol;

  public static final String JSON_PROPERTY_ACTIVE_TRANSFERS = "active_transfers";
  private List<Transfer> activeTransfers = new ArrayList<>();

  public static final String JSON_PROPERTY_NODE = "node";
  private String node;

  public ConnectionStatus() {
  }

  public ConnectionStatus username(String username) {
    
    this.username = username;
    return this;
  }

  /**
   * connected username
   * @return username
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_USERNAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getUsername() {
    return username;
  }


  @JsonProperty(JSON_PROPERTY_USERNAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setUsername(String username) {
    this.username = username;
  }

  public ConnectionStatus connectionId(String connectionId) {
    
    this.connectionId = connectionId;
    return this;
  }

  /**
   * unique connection identifier
   * @return connectionId
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_CONNECTION_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getConnectionId() {
    return connectionId;
  }


  @JsonProperty(JSON_PROPERTY_CONNECTION_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setConnectionId(String connectionId) {
    this.connectionId = connectionId;
  }

  public ConnectionStatus clientVersion(String clientVersion) {
    
    this.clientVersion = clientVersion;
    return this;
  }

  /**
   * client version
   * @return clientVersion
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_CLIENT_VERSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getClientVersion() {
    return clientVersion;
  }


  @JsonProperty(JSON_PROPERTY_CLIENT_VERSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setClientVersion(String clientVersion) {
    this.clientVersion = clientVersion;
  }

  public ConnectionStatus remoteAddress(String remoteAddress) {
    
    this.remoteAddress = remoteAddress;
    return this;
  }

  /**
   * Remote address for the connected client
   * @return remoteAddress
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_REMOTE_ADDRESS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getRemoteAddress() {
    return remoteAddress;
  }


  @JsonProperty(JSON_PROPERTY_REMOTE_ADDRESS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRemoteAddress(String remoteAddress) {
    this.remoteAddress = remoteAddress;
  }

  public ConnectionStatus connectionTime(Long connectionTime) {
    
    this.connectionTime = connectionTime;
    return this;
  }

  /**
   * connection time as unix timestamp in milliseconds
   * @return connectionTime
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_CONNECTION_TIME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Long getConnectionTime() {
    return connectionTime;
  }


  @JsonProperty(JSON_PROPERTY_CONNECTION_TIME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setConnectionTime(Long connectionTime) {
    this.connectionTime = connectionTime;
  }

  public ConnectionStatus command(String command) {
    
    this.command = command;
    return this;
  }

  /**
   * Last SSH/FTP command or WebDAV method
   * @return command
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_COMMAND)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getCommand() {
    return command;
  }


  @JsonProperty(JSON_PROPERTY_COMMAND)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCommand(String command) {
    this.command = command;
  }

  public ConnectionStatus lastActivity(Long lastActivity) {
    
    this.lastActivity = lastActivity;
    return this;
  }

  /**
   * last client activity as unix timestamp in milliseconds
   * @return lastActivity
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_LAST_ACTIVITY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Long getLastActivity() {
    return lastActivity;
  }


  @JsonProperty(JSON_PROPERTY_LAST_ACTIVITY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLastActivity(Long lastActivity) {
    this.lastActivity = lastActivity;
  }

  public ConnectionStatus protocol(ProtocolEnum protocol) {
    
    this.protocol = protocol;
    return this;
  }

  /**
   * Get protocol
   * @return protocol
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_PROTOCOL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public ProtocolEnum getProtocol() {
    return protocol;
  }


  @JsonProperty(JSON_PROPERTY_PROTOCOL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setProtocol(ProtocolEnum protocol) {
    this.protocol = protocol;
  }

  public ConnectionStatus activeTransfers(List<Transfer> activeTransfers) {
    
    this.activeTransfers = activeTransfers;
    return this;
  }

  public ConnectionStatus addActiveTransfersItem(Transfer activeTransfersItem) {
    if (this.activeTransfers == null) {
      this.activeTransfers = new ArrayList<>();
    }
    this.activeTransfers.add(activeTransfersItem);
    return this;
  }

  /**
   * Get activeTransfers
   * @return activeTransfers
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ACTIVE_TRANSFERS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<Transfer> getActiveTransfers() {
    return activeTransfers;
  }


  @JsonProperty(JSON_PROPERTY_ACTIVE_TRANSFERS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setActiveTransfers(List<Transfer> activeTransfers) {
    this.activeTransfers = activeTransfers;
  }

  public ConnectionStatus node(String node) {
    
    this.node = node;
    return this;
  }

  /**
   * Node identifier, omitted for single node installations
   * @return node
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_NODE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getNode() {
    return node;
  }


  @JsonProperty(JSON_PROPERTY_NODE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setNode(String node) {
    this.node = node;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ConnectionStatus connectionStatus = (ConnectionStatus) o;
    return Objects.equals(this.username, connectionStatus.username) &&
        Objects.equals(this.connectionId, connectionStatus.connectionId) &&
        Objects.equals(this.clientVersion, connectionStatus.clientVersion) &&
        Objects.equals(this.remoteAddress, connectionStatus.remoteAddress) &&
        Objects.equals(this.connectionTime, connectionStatus.connectionTime) &&
        Objects.equals(this.command, connectionStatus.command) &&
        Objects.equals(this.lastActivity, connectionStatus.lastActivity) &&
        Objects.equals(this.protocol, connectionStatus.protocol) &&
        Objects.equals(this.activeTransfers, connectionStatus.activeTransfers) &&
        Objects.equals(this.node, connectionStatus.node);
  }

  @Override
  public int hashCode() {
    return Objects.hash(username, connectionId, clientVersion, remoteAddress, connectionTime, command, lastActivity, protocol, activeTransfers, node);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ConnectionStatus {\n");
    sb.append("    username: ").append(toIndentedString(username)).append("\n");
    sb.append("    connectionId: ").append(toIndentedString(connectionId)).append("\n");
    sb.append("    clientVersion: ").append(toIndentedString(clientVersion)).append("\n");
    sb.append("    remoteAddress: ").append(toIndentedString(remoteAddress)).append("\n");
    sb.append("    connectionTime: ").append(toIndentedString(connectionTime)).append("\n");
    sb.append("    command: ").append(toIndentedString(command)).append("\n");
    sb.append("    lastActivity: ").append(toIndentedString(lastActivity)).append("\n");
    sb.append("    protocol: ").append(toIndentedString(protocol)).append("\n");
    sb.append("    activeTransfers: ").append(toIndentedString(activeTransfers)).append("\n");
    sb.append("    node: ").append(toIndentedString(node)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

